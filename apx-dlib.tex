\section{Net-helper TCP}

\begin{lstlisting}
typedef struct {
    uint32_t size;
} header_t;

typedef struct {
    const void * data;
    size_t size;
} msgbuf_t;
\end{lstlisting}

\subsection{initializer}

\subsubsection{Socket Address}
\label{apx-nh-init}
\begin{lstlisting}
typedef union {
    struct sockaddr sa;
    struct sockaddr_storage ss;
    struct sockaddr_in sin;
    struct sockaddr_in6 sin6;
} sockaddr_t;
\end{lstlisting}

\subsection{Send to peer}
\label{nh-send2peer}

\begin{lstlisting}
int send_to_peer(const struct nodeID *self, struct nodeID *to,
                 const uint8_t *buffer_ptr, int buffer_size)
{
    client_t cl;
    local_t *loc;
    struct timeval zero = {
        .tv_sec = 0,
        .tv_usec = 0
    };
    const msgbuf_t msg = {
        .data = buffer_ptr,
        .size = buffer_size
    };

    assert(self->loc != NULL);

    loc = self->loc;

    cl = dict_search(loc->neighbors, &to->addr);
    if (!client_valid(cl)) {
        int clfd;

        if (client_connect(cl, &to->addr) == -1) {
            return -1;
        }
        clfd = client_get_fd(cl);
        if (sockaddr_send_hello(&self->addr, clfd) == -1) {
            close(clfd);
            return -1;
        }
    }

    if (client_write(cl, &msg) == -1) return -1;
    if (aqueue_scan_dict(loc->aqueue, loc->neighbors,
                         loc->srvfd, NULL, &zero) == -1) {
        return -1;
    }
    return buffer_size;
}
\end{lstlisting}

\subsection{Receive from peer}
\label{nh-rcv-peer}

\begin{lstlisting}
int recv_from_peer(const struct nodeID *self, struct nodeID **remote,
                   uint8_t *buffer_ptr, int buffer_size)
{
    local_t *loc;
    client_t sender;
    nodeid_t *sender_node;
    const msgbuf_t *msg;

    assert(self->loc != NULL);
    loc = self->loc;

    while (aqueue_empty(loc->aqueue)) {
        if (aqueue_scan_dict(loc->aqueue, loc->neighbors, loc->srvfd,
                             NULL, NULL) == -1) {
            return -1;
        }
    }

    sender = aqueue_next(loc->aqueue);
    msg = client_read(sender);
    assert(msg != NULL);

    if (msg->size > buffer_size) {
        print_err(``recv_from_peer'', NULL, ENOBUFS);
        return -1;
    }
    memcpy((void *)buffer_ptr, msg->data, msg->size);

    sender_node = create_node(NULL, 0);
    sockaddr_copy(&sender_node->addr, client_get_remote(sender));
    *remote = sender_node;

    return (int) msg->size;
}
\end{lstlisting}

\subsection{Wait for data}
\label{nh-wait4data}
\begin{lstlisting}
int wait4data(const struct nodeID *self, struct timeval *tout,
              int *user_fds)
{
    local_t *loc;
    struct timeval tmp;
    int res, ret;
    tout_t T;

    assert(self->loc != NULL);
    loc = self->loc;

    T = tout_new(tout);
    ret = 0;
    while (!tout_expired(T) && aqueue_empty(loc->aqueue)) {
        res = aqueue_scan_dict(loc->aqueue, loc->neighbors, loc->srvfd,
                               NULL, tout_remaining(T, &tmp));
        if (res == -1) {
            tout_del(T);
            return -1;
        }
        ret |= res;
    }
    tout_del(T);

    return ret || !aqueue_empty(loc->aqueue);
}
\end{lstlisting}


\subsection{Other functions}
\label{nh-oth-func}

\section{Dictionary}
\begin{lstlisting}
struct dict {
    dhash_t *hash;
    size_t nelems;
};

/* Return 1 to continue, 0 to stop scanning */
typedef int (* dict_foreach_t) (void *ctx, const sockaddr_t * addr,
client_t cl);

/* Destructor must support NULL as input value */
dict_t dict_new (struct tag *);

/* Returns the inner pointer to client instance */
client_t dict_search (dict_t d, const sockaddr_t *);

void dict_foreach (dict_t d, dict_foreach_t cb, void * ctx);

void dict_del (dict_t d);

\end{lstlisting}


\section{Libdacav}
